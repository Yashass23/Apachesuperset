(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[5770],{76613:t=>{function e(t){if(!(this instanceof e))return new e(t);this._bbox=t||[1/0,1/0,-1/0,-1/0],this._valid=!!t}t.exports=e,e.prototype.include=function(t){return this._valid=!0,this._bbox[0]=Math.min(this._bbox[0],t[0]),this._bbox[1]=Math.min(this._bbox[1],t[1]),this._bbox[2]=Math.max(this._bbox[2],t[0]),this._bbox[3]=Math.max(this._bbox[3],t[1]),this},e.prototype.equals=function(t){var i;return i=t instanceof e?t.bbox():t,this._bbox[0]==i[0]&&this._bbox[1]==i[1]&&this._bbox[2]==i[2]&&this._bbox[3]==i[3]},e.prototype.center=function(t){return this._valid?[(this._bbox[0]+this._bbox[2])/2,(this._bbox[1]+this._bbox[3])/2]:null},e.prototype.union=function(t){var i;return this._valid=!0,i=t instanceof e?t.bbox():t,this._bbox[0]=Math.min(this._bbox[0],i[0]),this._bbox[1]=Math.min(this._bbox[1],i[1]),this._bbox[2]=Math.max(this._bbox[2],i[2]),this._bbox[3]=Math.max(this._bbox[3],i[3]),this},e.prototype.bbox=function(){return this._valid?this._bbox:null},e.prototype.contains=function(t){if(!t)return this._fastContains();if(!this._valid)return null;var e=t[0],i=t[1];return this._bbox[0]<=e&&this._bbox[1]<=i&&this._bbox[2]>=e&&this._bbox[3]>=i},e.prototype.intersect=function(t){return this._valid?(i=t instanceof e?t.bbox():t,!(this._bbox[0]>i[2]||this._bbox[2]<i[0]||this._bbox[3]<i[1]||this._bbox[1]>i[3])):null;var i},e.prototype._fastContains=function(){if(!this._valid)return new Function("return null;");var t="return "+this._bbox[0]+"<= ll[0] &&"+this._bbox[1]+"<= ll[1] &&"+this._bbox[2]+">= ll[0] &&"+this._bbox[3]+">= ll[1]";return new Function("ll",t)},e.prototype.polygon=function(){return this._valid?{type:"Polygon",coordinates:[[[this._bbox[0],this._bbox[1]],[this._bbox[2],this._bbox[1]],[this._bbox[2],this._bbox[3]],[this._bbox[0],this._bbox[3]],[this._bbox[0],this._bbox[1]]]]}:null}},7829:t=>{t.exports=function(t){return function t(e){return Array.isArray(e)&&e.length&&"number"==typeof e[0]?[e]:e.reduce((function(e,i){return Array.isArray(i)&&Array.isArray(i[0])?e.concat(t(i)):(e.push(i),e)}),[])}(t)}},34506:(t,e,i)=>{var n=i(99340),o=i(63),s=i(7829);o instanceof Function||(o=o.default),t.exports=function(t){if(!t)return[];var e=o(n(t)),i=[];return e.features.forEach((function(t){t.geometry&&(i=i.concat(s(t.geometry.coordinates)))})),i}},29319:(t,e,i)=>{var n=i(34506),o=i(13692),s=i(76613),r={features:["FeatureCollection"],coordinates:["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"],geometry:["Feature"],geometries:["GeometryCollection"]},a=Object.keys(r);function l(t){for(var e=s(),i=n(t),o=0;o<i.length;o++)e.include(i[o]);return e}t.exports=function(t){return l(t).bbox()},t.exports.polygon=function(t){return l(t).polygon()},t.exports.bboxify=function(t){return o(t).map((function(t){t&&a.some((function(e){return!!t[e]&&-1!==r[e].indexOf(t.type)}))&&(t.bbox=l(t).bbox(),this.update(t))}))}},99340:t=>{t.exports=function(t){if(!t||!t.type)return null;var i=e[t.type];return i?"geometry"===i?{type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:t}]}:"feature"===i?{type:"FeatureCollection",features:[t]}:"featurecollection"===i?t:void 0:null};var e={Point:"geometry",MultiPoint:"geometry",LineString:"geometry",MultiLineString:"geometry",Polygon:"geometry",MultiPolygon:"geometry",GeometryCollection:"geometry",Feature:"feature",FeatureCollection:"featurecollection"}},69588:(t,e,i)=>{"use strict";i.d(e,{Z:()=>dt});var n=i(4942),o=i(36750),s=i(67186),r=i(5259),a=i(37832),l=i(13717),c=i(33321),u=i(41576),d=i(39769),g=i(53982),f=i(4912),p=i(1953),h=i(45383),y=i(91575);const v=()=>{},x={10241:9987,10240:9729,10242:33071,10243:33071};function m(t,e,i,n){const o=Math.min(i/e.width,n/e.height),s=Math.floor(e.width*o),r=Math.floor(e.height*o);return 1===o?{data:e,width:s,height:r}:(t.canvas.height=r,t.canvas.width=s,t.clearRect(0,0,s,r),t.drawImage(e,0,0,e.width,e.height,0,0,s,r),{data:t.canvas,width:s,height:r})}function P(t){return t&&(t.id||t.url)}function _(t,e,i){for(let n=0;n<e.length;n++){const{icon:o,xOffset:s}=e[n];t[P(o)]={...o,x:s,y:i}}}class b{constructor(t,e){let{onUpdate:i=v,onError:o=v}=e;(0,n.Z)(this,"gl",void 0),(0,n.Z)(this,"onUpdate",void 0),(0,n.Z)(this,"onError",void 0),(0,n.Z)(this,"_loadOptions",null),(0,n.Z)(this,"_texture",null),(0,n.Z)(this,"_externalTexture",null),(0,n.Z)(this,"_mapping",{}),(0,n.Z)(this,"_textureParameters",null),(0,n.Z)(this,"_pendingCount",0),(0,n.Z)(this,"_autoPacking",!1),(0,n.Z)(this,"_xOffset",0),(0,n.Z)(this,"_yOffset",0),(0,n.Z)(this,"_rowHeight",0),(0,n.Z)(this,"_buffer",4),(0,n.Z)(this,"_canvasWidth",1024),(0,n.Z)(this,"_canvasHeight",0),(0,n.Z)(this,"_canvas",null),this.gl=t,this.onUpdate=i,this.onError=o}finalize(){var t;null===(t=this._texture)||void 0===t||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?P(t):t;return this._mapping[e]||{}}setProps(t){let{loadOptions:e,autoPacking:i,iconAtlas:n,iconMapping:o,textureParameters:s}=t;var r;e&&(this._loadOptions=e),void 0!==i&&(this._autoPacking=i),o&&(this._mapping=o),n&&(null===(r=this._texture)||void 0===r||r.delete(),this._texture=null,this._externalTexture=n),s&&(this._textureParameters=s)}get isLoaded(){return 0===this._pendingCount}packIcons(t,e){if(!this._autoPacking||"undefined"==typeof document)return;const i=Object.values(function(t,e,i){if(!t||!e)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,y.jB)(t);for(const t of o){s.index++;const o=e(t,s),r=P(o);if(!o)throw new Error("Icon is missing.");if(!o.url)throw new Error("Icon url is missing.");n[r]||i[r]&&o.url===i[r].url||(n[r]={...o,source:t,sourceIndex:s.index})}return n}(t,e,this._mapping)||{});if(i.length>0){const{mapping:t,xOffset:e,yOffset:n,rowHeight:o,canvasHeight:s}=function(t){let{icons:e,buffer:i,mapping:n={},xOffset:o=0,yOffset:s=0,rowHeight:r=0,canvasWidth:a}=t,l=[];for(let t=0;t<e.length;t++){const c=e[t];if(!n[P(c)]){const{height:t,width:e}=c;o+e+i>a&&(_(n,l,s),o=0,s=r+s+i,r=0,l=[]),l.push({icon:c,xOffset:o}),o=o+e+i,r=Math.max(r,t)}}return l.length>0&&_(n,l,s),{mapping:n,rowHeight:r,xOffset:o,yOffset:s,canvasWidth:a,canvasHeight:(c=r+s+i,Math.pow(2,Math.ceil(Math.log2(c))))};var c}({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=t,this._xOffset=e,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new f.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||x})),this._texture.height!==this._canvasHeight&&(this._texture=function(t,e,i,n){const o=t.width,s=t.height,r=new f.Z(t.gl,{width:e,height:i,parameters:n});return(0,p.Lv)(t,r,{targetY:0,width:o,height:s}),t.delete(),r}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||x)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(t){const e=this._canvas.getContext("2d",{willReadFrequently:!0});for(const i of t)this._pendingCount++,(0,h.z)(i.url,this._loadOptions).then((t=>{const n=P(i),o=this._mapping[n],{x:s,y:r,width:a,height:l}=o,{data:c,width:u,height:d}=m(e,t,a,l);this._texture.setSubImageData({data:c,x:s+(a-u)/2,y:r+(l-d)/2,width:u,height:d}),o.width=u,o.height=d,this._texture.generateMipmap(),this.onUpdate()})).catch((t=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:t})})).finally((()=>{this._pendingCount--}))}}const C=[0,0,0,255],S={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:C},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0}};class L extends r.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.state={iconManager:new b(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})},this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:C},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(t){super.updateState(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=e,{iconManager:u}=this.state,d=s||this.internalState.isAsyncPropLoading("iconAtlas");if(u.setProps({loadOptions:e.loadOptions,autoPacking:!d,iconAtlas:s,iconMapping:d?r:null,textureParameters:c}),d?i.iconMapping!==e.iconMapping&&o.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&u.packIcons(a,l),n.extensionsChanged){var g;const{gl:t}=this.context;null===(g=this.state.model)||void 0===g||g.delete(),this.state.model=this._getModel(t),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(t){super.finalizeState(t),this.state.iconManager.finalize()}draw(t){let{uniforms:e}=t;const{sizeScale:i,sizeMinPixels:n,sizeMaxPixels:o,sizeUnits:s,billboard:r,alphaCutoff:a}=this.props,{iconManager:l}=this.state,u=l.getTexture();u&&this.state.model.setUniforms(e).setUniforms({iconsTexture:u,iconsTextureDim:[u.width,u.height],sizeUnits:c.iI[s],sizeScale:i,sizeMinPixels:n,sizeMaxPixels:o,billboard:r,alphaCutoff:a}).draw()}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){var e;const i=null===(e=this.getCurrentLayer())||void 0===e?void 0:e.props.onIconError;i?i(t):u.Z.error(t.error.message)()}getInstanceOffset(t){const{width:e,height:i,anchorX:n=e/2,anchorY:o=i/2}=this.state.iconManager.getIconMapping(t);return[e/2-n,i/2-o]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){const{x:e,y:i,width:n,height:o}=this.state.iconManager.getIconMapping(t);return[e,i,n,o]}}(0,n.Z)(L,"defaultProps",S),(0,n.Z)(L,"layerName","IconLayer");var w=i(73715);const z=.75,M=[];class O extends L{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float sdfBuffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(i,n)}}})}updateState(t){super.updateState(t);const{props:e,oldProps:i}=t;let{outlineColor:n}=e;n!==i.outlineColor&&(n=n.map((t=>t/255)),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!e.sdf&&e.outlineWidth&&u.Z.warn("".concat(this.id,": fontSettings.sdf is required to render outline"))()}draw(t){const{sdf:e,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state,s=n?Math.max(i,z*(1-n)):-1;if(t.uniforms={...t.uniforms,sdfBuffer:z,outlineBuffer:s,gamma:i,sdf:Boolean(e),outlineColor:o},super.draw(t),e&&n){const{iconManager:t}=this.state;t.getTexture()&&this.state.model.draw({uniforms:{outlineBuffer:z}})}}getInstanceOffset(t){return t?Array.from(t).flatMap((t=>super.getInstanceOffset(t))):M}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).flatMap((t=>super.getInstanceIconFrame(t))):M}}(0,n.Z)(O,"defaultProps",{getIconOffsets:{type:"accessor",value:t=>t.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}}),(0,n.Z)(O,"layerName","MultiIconLayer");const A=1e20;class F{constructor(t){let{fontSize:e=24,buffer:i=3,radius:n=8,cutoff:o=.25,fontFamily:s="sans-serif",fontWeight:r="normal",fontStyle:a="normal"}=void 0===t?{}:t;this.buffer=i,this.cutoff=o,this.radius=n;const l=this.size=e+4*i,c=this._createCanvas(l),u=this.ctx=c.getContext("2d",{willReadFrequently:!0});u.font=`${a} ${r} ${e}px ${s}`,u.textBaseline="alphabetic",u.textAlign="left",u.fillStyle="black",this.gridOuter=new Float64Array(l*l),this.gridInner=new Float64Array(l*l),this.f=new Float64Array(l),this.z=new Float64Array(l+1),this.v=new Uint16Array(l)}_createCanvas(t){const e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){const{width:e,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:o,actualBoundingBoxRight:s}=this.ctx.measureText(t),r=Math.ceil(i),a=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(s-o))),l=Math.min(this.size-this.buffer,r+Math.ceil(n)),c=a+2*this.buffer,u=l+2*this.buffer,d=Math.max(c*u,0),g=new Uint8ClampedArray(d),f={data:g,width:c,height:u,glyphWidth:a,glyphHeight:l,glyphTop:r,glyphLeft:0,glyphAdvance:e};if(0===a||0===l)return f;const{ctx:p,buffer:h,gridInner:y,gridOuter:v}=this;p.clearRect(h,h,a,l),p.fillText(t,h,h+r);const x=p.getImageData(h,h,a,l);v.fill(A,0,d),y.fill(0,0,d);for(let t=0;t<l;t++)for(let e=0;e<a;e++){const i=x.data[4*(t*a+e)+3]/255;if(0===i)continue;const n=(t+h)*c+e+h;if(1===i)v[n]=0,y[n]=A;else{const t=.5-i;v[n]=t>0?t*t:0,y[n]=t<0?t*t:0}}I(v,0,0,c,u,c,this.f,this.v,this.z),I(y,h,h,a,l,c,this.f,this.v,this.z);for(let t=0;t<d;t++){const e=Math.sqrt(v[t])-Math.sqrt(y[t]);g[t]=Math.round(255-255*(e/this.radius+this.cutoff))}return f}}function I(t,e,i,n,o,s,r,a,l){for(let c=e;c<e+n;c++)T(t,i*s+c,s,o,r,a,l);for(let c=i;c<i+o;c++)T(t,c*s+e,1,n,r,a,l)}function T(t,e,i,n,o,s,r){s[0]=0,r[0]=-A,r[1]=A,o[0]=t[e];for(let a=1,l=0,c=0;a<n;a++){o[a]=t[e+a*i];const n=a*a;do{const t=s[l];c=(o[a]-o[t]+n-t*t)/(a-t)/2}while(c<=r[l]&&--l>-1);l++,s[l]=a,r[l]=c,r[l+1]=A}for(let a=0,l=0;a<n;a++){for(;r[l+1]<a;)l++;const n=s[l],c=a-n;t[e+a*i]=o[n]+c*c}}const E=[];function R(t,e,i,n){let o=0;for(let r=e;r<i;r++){var s;o+=(null===(s=n[t[r]])||void 0===s?void 0:s.layoutWidth)||0}return o}function k(t,e,i,n,o,s){let r=e,a=0;for(let l=e;l<i;l++){const e=R(t,l,l+1,o);a+e>n&&(r<l&&s.push(l),r=l,a=0),a+=e}return a}function W(t,e,i,n,o,s){void 0===o&&(o=0),void 0===s&&(s=t.length);const r=[];return"break-all"===e?k(t,o,s,i,n,r):function(t,e,i,n,o,s){let r=e,a=e,l=e,c=0;for(let u=e;u<i;u++)if(" "===t[u]?l=u+1:" "!==t[u+1]&&u+1!==i||(l=u+1),l>a){let e=R(t,a,l,o);c+e>n&&(r<a&&(s.push(a),r=a,c=0),e>n&&(e=k(t,a,l,n,o,s),r=s[s.length-1])),a=l,c+=e}}(t,o,s,i,n,r),r}function B(t,e,i,n,o,s){let r=0,a=0;for(let s=e;s<i;s++){const e=t[s],i=n[e];i?(a||(a=i.layoutHeight),o[s]=r+i.layoutWidth/2,r+=i.layoutWidth):(u.Z.warn("Missing character: ".concat(e," (").concat(e.codePointAt(0),")"))(),o[s]=r,r+=32)}s[0]=r,s[1]=a}class Z{constructor(t){void 0===t&&(t=5),(0,n.Z)(this,"limit",void 0),(0,n.Z)(this,"_cache",{}),(0,n.Z)(this,"_order",[]),this.limit=t}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(delete this._cache[t],this._deleteOrder(t))}_deleteOrder(t){const e=this._order.indexOf(t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}const j={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1};let U=new Z(3);function D(t,e){for(let i=0;i<t.length;i++)e.data[4*i+3]=t[i]}function G(t,e,i,n){t.font="".concat(n," ").concat(i,"px ").concat(e),t.fillStyle="#000",t.textBaseline="alphabetic",t.textAlign="left"}class N{constructor(){(0,n.Z)(this,"props",{...j}),(0,n.Z)(this,"_key",void 0),(0,n.Z)(this,"_atlas",void 0)}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:t,buffer:e}=this.props;return(1.2*t+2*e)/t}setProps(t){void 0===t&&(t={}),Object.assign(this.props,t),this._key=this._getKey();const e=function(t,e){let i;i="string"==typeof e?new Set(Array.from(e)):new Set(e);const n=U.get(t);if(!n)return i;for(const t in n.mapping)i.has(t)&&i.delete(t);return i}(this._key,this.props.characterSet),i=U.get(this._key);if(i&&0===e.size)return void(this._atlas!==i&&(this._atlas=i));const n=this._generateFontAtlas(e,i);this._atlas=n,U.set(this._key,n)}_generateFontAtlas(t,e){const{fontFamily:i,fontWeight:n,fontSize:o,buffer:s,sdf:r,radius:a,cutoff:l}=this.props;let c=e&&e.data;c||(c=document.createElement("canvas"),c.width=1024);const u=c.getContext("2d",{willReadFrequently:!0});G(u,i,o,n);const{mapping:d,canvasHeight:g,xOffset:f,yOffset:p}=function(t){let{characterSet:e,getFontWidth:i,fontHeight:n,buffer:o,maxCanvasWidth:s,mapping:r={},xOffset:a=0,yOffset:l=0}=t,c=0,u=a;const d=n+2*o;for(const t of e)if(!r[t]){const e=i(t);u+e+2*o>s&&(u=0,c++),r[t]={x:u+o,y:l+c*d+o,width:e,height:d,layoutWidth:e,layoutHeight:n},u+=e+2*o}return{mapping:r,xOffset:u,yOffset:l+c*d,canvasHeight:(g=l+(c+1)*d,Math.pow(2,Math.ceil(Math.log2(g))))};var g}({getFontWidth:t=>u.measureText(t).width,fontHeight:1.2*o,buffer:s,characterSet:t,maxCanvasWidth:1024,...e&&{mapping:e.mapping,xOffset:e.xOffset,yOffset:e.yOffset}});if(c.height!==g){const t=u.getImageData(0,0,c.width,c.height);c.height=g,u.putImageData(t,0,0)}if(G(u,i,o,n),r){const e=new F({fontSize:o,buffer:s,radius:a,cutoff:l,fontFamily:i,fontWeight:"".concat(n)});for(const i of t){const{data:t,width:n,height:s,glyphTop:r}=e.draw(i);d[i].width=n,d[i].layoutOffsetY=.9*o-r;const a=u.createImageData(n,s);D(t,a),u.putImageData(a,d[i].x,d[i].y)}}else for(const e of t)u.fillText(e,d[e].x,d[e].y+s+.9*o);return{xOffset:f,yOffset:p,mapping:d,data:c,width:c.width,height:c.height}}_getKey(){const{fontFamily:t,fontWeight:e,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:r}=this.props;return o?"".concat(t," ").concat(e," ").concat(i," ").concat(n," ").concat(s," ").concat(r):"".concat(t," ").concat(e," ").concat(i," ").concat(n)}}const H={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:t=>t.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class V extends r.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[a.Z,l.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t);const{changeFlags:e}=t;if(e.extensionsChanged){var i;const{gl:t}=this.context;null===(i=this.state.model)||void 0===i||i.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{billboard:i,sizeScale:n,sizeUnits:o,sizeMinPixels:s,sizeMaxPixels:r,getLineWidth:a}=this.props;let{padding:l}=this.props;l.length<4&&(l=[l[0],l[1],l[0],l[1]]),this.state.model.setUniforms(e).setUniforms({billboard:i,stroked:Boolean(a),padding:l,sizeUnits:c.iI[o],sizeScale:n,sizeMinPixels:s,sizeMaxPixels:r}).draw()}_getModel(t){return new d.Z(t,{...this.getShaders(),id:this.props.id,geometry:new g.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}(0,n.Z)(V,"defaultProps",H),(0,n.Z)(V,"layerName","TextBackgroundLayer");const K={start:1,middle:0,end:-1},J={top:1,center:0,bottom:-1},q=[0,0,0,255],X={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:q},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:j.characterSet},fontFamily:j.fontFamily,fontWeight:j.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:q},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:q},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class Y extends o.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0),(0,n.Z)(this,"getBoundingRect",((t,e)=>{let{size:[i,n]}=this.transformParagraph(t,e);const{fontSize:o}=this.state.fontAtlasManager.props;i/=o,n/=o;const{getTextAnchor:s,getAlignmentBaseline:r}=this.props;return[(K["function"==typeof s?s(t,e):s]-1)*i/2,(J["function"==typeof r?r(t,e):r]-1)*n/2,i,n]})),(0,n.Z)(this,"getIconOffsets",((t,e)=>{const{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:o,y:s,rowWidth:r,size:[a,l]}=this.transformParagraph(t,e),c=K["function"==typeof i?i(t,e):i],u=J["function"==typeof n?n(t,e):n],d=o.length,g=new Array(2*d);let f=0;for(let t=0;t<d;t++){const e=(1-c)*(a-r[t])/2;g[f++]=(c-1)*a/2+e+o[t],g[f++]=(u-1)*l/2+s[t]}return g}))}initializeState(){this.state={styleVersion:0,fontAtlasManager:new N},this.props.maxWidth>0&&u.Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(t){const{props:e,oldProps:i,changeFlags:n}=t;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText(),(this._updateFontAtlas()||e.lineHeight!==i.lineHeight||e.wordBreak!==i.wordBreak||e.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo(t){let{info:e}=t;return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:t,fontFamily:e,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:o}=this.state,s={...t,characterSet:o,fontFamily:e,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(const t in s)if(s[t]!==n.props[t])return n.setProps(s),!0;return!1}_updateText(){var t;const{data:e,characterSet:i}=this.props,n=null===(t=e.attributes)||void 0===t?void 0:t.getText;let o,{getText:s}=this.props,r=e.startIndices;const a="auto"===i&&new Set;if(n&&r){const{texts:t,characterCount:i}=function(t){let{value:e,length:i,stride:n,offset:o,startIndices:s,characterSet:r}=t;const a=e.BYTES_PER_ELEMENT,l=n?n/a:1,c=o?o/a:0,u=s[i]||Math.ceil((e.length-c)/l),d=r&&new Set,g=new Array(i);let f=e;if(l>1||c>0){f=new(0,e.constructor)(u);for(let t=0;t<u;t++)f[t]=e[t*l+c]}for(let t=0;t<i;t++){const e=s[t],i=s[t+1]||u,n=f.subarray(e,i);g[t]=String.fromCodePoint.apply(null,n),d&&n.forEach(d.add,d)}if(d)for(const t of d)r.add(String.fromCodePoint(t));return{texts:g,characterCount:u}}({...ArrayBuffer.isView(n)?{value:n}:n,length:e.length,startIndices:r,characterSet:a});o=i,s=(e,i)=>{let{index:n}=i;return t[n]}}else{const{iterable:t,objectInfo:i}=(0,y.jB)(e);r=[0],o=0;for(const e of t){i.index++;const t=Array.from(s(e,i)||"");a&&t.forEach(a.add,a),o+=t.length,r.push(o)}}this.setState({getText:s,startIndices:r,numInstances:o,characterSet:a||i})}transformParagraph(t,e){const{fontAtlasManager:i}=this.state,n=i.mapping,o=this.state.getText,{wordBreak:s,lineHeight:r,maxWidth:a}=this.props;return function(t,e,i,n,o){const s=Array.from(t),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),u=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,d=[0,0],g=[0,0];let f=0,p=0,h=0;for(let t=0;t<=r;t++){const v=s[t];if("\n"!==v&&t!==r||(h=t),h>p){const t=u?W(s,i,n,o,p,h):E;for(let i=0;i<=t.length;i++){const n=0===i?p:t[i-1],r=i<t.length?t[i]:h;B(s,n,r,o,a,g);for(let t=n;t<r;t++){var y;const e=(null===(y=o[s[t]])||void 0===y?void 0:y.layoutOffsetY)||0;l[t]=f+g[1]/2+e,c[t]=g[0]}f+=g[1]*e,d[0]=Math.max(d[0],g[0])}p=h}"\n"===v&&(a[p]=0,l[p]=0,c[p]=0,p++)}return d[1]=f,{x:a,y:l,rowWidth:c,size:d}}(o(t,e)||"",r,s,a*i.props.fontSize,n)}renderLayers(){const{startIndices:t,numInstances:e,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:s},styleVersion:r}=this.state,{data:a,_dataDiff:l,getPosition:c,getColor:u,getSize:d,getAngle:g,getPixelOffset:f,getBackgroundColor:p,getBorderColor:h,getBorderWidth:y,backgroundPadding:v,background:x,billboard:m,fontSettings:P,outlineWidth:_,outlineColor:b,sizeScale:C,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z,updateTriggers:M}=this.props,A=this.getSubLayerClass("characters",O),F=this.getSubLayerClass("background",V);return[x&&new F({getFillColor:p,getLineColor:h,getLineWidth:y,padding:v,getPosition:c,getSize:d,getAngle:g,getPixelOffset:f,billboard:m,sizeScale:C,sizeUnits:S,sizeMinPixels:L,sizeMaxPixels:w,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getSize:z.getSize,getFillColor:z.getBackgroundColor,getLineColor:z.getBorderColor,getLineWidth:z.getBorderWidth,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:M.getPosition,getAngle:M.getAngle,getSize:M.getSize,getFillColor:M.getBackgroundColor,getLineColor:M.getBorderColor,getLineWidth:M.getBorderWidth,getPixelOffset:M.getPixelOffset,getBoundingRect:{getText:M.getText,getTextAnchor:M.getTextAnchor,getAlignmentBaseline:M.getAlignmentBaseline,styleVersion:r}}}),{data:a.attributes&&a.attributes.background?{length:a.length,attributes:a.attributes.background}:a,_dataDiff:l,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new A({sdf:P.sdf,smoothing:Number.isFinite(P.smoothing)?P.smoothing:j.smoothing,outlineWidth:_/(P.radius||j.radius),outlineColor:b,iconAtlas:o,iconMapping:s,getPosition:c,getColor:u,getSize:d,getAngle:g,getPixelOffset:f,billboard:m,sizeScale:C*n,sizeUnits:S,sizeMinPixels:L*n,sizeMaxPixels:w*n,transitions:z&&{getPosition:z.getPosition,getAngle:z.getAngle,getColor:z.getColor,getSize:z.getSize,getPixelOffset:z.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:M.getText,getPosition:M.getPosition,getAngle:M.getAngle,getColor:M.getColor,getSize:M.getSize,getPixelOffset:M.getPixelOffset,getIconOffsets:{getTextAnchor:M.getTextAnchor,getAlignmentBaseline:M.getAlignmentBaseline,styleVersion:r}}}),{data:a,_dataDiff:l,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(t){!function(t){u.Z.assert(Number.isFinite(t)&&t>=3,"Invalid cache limit"),U=new Z(t)}(t)}}(0,n.Z)(Y,"defaultProps",X),(0,n.Z)(Y,"layerName","TextLayer");var $=i(48897),Q=i(91567);const tt={circle:{type:w.Z,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:L,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:Y,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},et={type:$.Z,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},it={type:Q.Z,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function nt(t){let{type:e,props:i}=t;const n={};for(const t in i)n[t]=e.defaultProps[i[t]];return n}function ot(t,e){const{transitions:i,updateTriggers:n}=t.props,o={updateTriggers:{},transitions:i&&{getPosition:i.geometry}};for(const s in e){const r=e[s];let a=t.props[s];s.startsWith("get")&&(a=t.getSubLayerAccessor(a),o.updateTriggers[r]=n[s],i&&(o.transitions[r]=i[s])),o[r]=a}return o}function st(t,e,i){void 0===i&&(i={});const n={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=t.length}=i;for(let i=o;i<s;i++){const o=t[i],{geometry:s}=o;if(s)if("GeometryCollection"===s.type){u.Z.assert(Array.isArray(s.geometries),"GeoJSON does not have geometries array");const{geometries:t}=s;for(let s=0;s<t.length;s++)rt(t[s],n,e,o,i)}else rt(s,n,e,o,i)}return n}function rt(t,e,i,n,o){const{type:s,coordinates:r}=t,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:d}=e;if(function(t,e){let i=at[t];for(u.Z.assert(i,"Unknown GeoJSON type ".concat(t));e&&--i>0;)e=e[0];return e&&Number.isFinite(e[0])}(s,r))switch(s){case"Point":a.push(i({geometry:t},n,o));break;case"MultiPoint":r.forEach((t=>{a.push(i({geometry:{type:"Point",coordinates:t}},n,o))}));break;case"LineString":l.push(i({geometry:t},n,o));break;case"MultiLineString":r.forEach((t=>{l.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"Polygon":c.push(i({geometry:t},n,o)),r.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"MultiPolygon":r.forEach((t=>{c.push(i({geometry:{type:"Polygon",coordinates:t}},n,o)),t.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}))}))}else u.Z.warn("".concat(s," coordinates are malformed"))()}const at={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function lt(t){return t.geometry.coordinates}const ct=["points","linestrings","polygons"],ut={...nt(tt.circle),...nt(tt.icon),...nt(tt.text),...nt(et),...nt(it),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:t=>t.properties.icon},getText:{type:"accessor",value:t=>t.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class dt extends o.Z{initializeState(){this.state={layerProps:{},features:{}}}updateState(t){let{props:e,changeFlags:i}=t;if(!i.dataChanged)return;const{data:n}=this.props,o=n&&"points"in n&&"polygons"in n&&"lines"in n;this.setState({binary:o}),o?this._updateStateBinary({props:e,changeFlags:i}):this._updateStateJSON({props:e,changeFlags:i})}_updateStateBinary(t){let{props:e,changeFlags:i}=t;const n=function(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:n,lines:o,polygons:s}=t,r=function(t,e){const i={points:null,lines:null,polygons:null};for(const n in i){const o=t[n].globalFeatureIds.value;i[n]=new Uint8ClampedArray(3*o.length);const s=[];for(let t=0;t<o.length;t++)e(o[t],s),i[n][3*t+0]=s[0],i[n][3*t+1]=s[1],i[n][3*t+2]=s[2]}return i}(t,e);return i.points.data={length:n.positions.value.length/n.positions.size,attributes:{...n.attributes,getPosition:n.positions,instancePickingColors:{size:3,value:r.points}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},i.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},i.lines._pathType="open",i.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygons._normalize=!1,s.triangles&&(i.polygons.data.attributes.indices=s.triangles.value),i.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygonsOutline._pathType="open",i}(e.data,this.encodePickingColor);this.setState({layerProps:n})}_updateStateJSON(t){let{props:e,changeFlags:i}=t;const n=function(t){if(Array.isArray(t))return t;switch(u.Z.assert(t.type,"GeoJSON does not have type"),t.type){case"Feature":return[t];case"FeatureCollection":return u.Z.assert(Array.isArray(t.features),"GeoJSON does not have features array"),t.features;default:return[{geometry:t}]}}(e.data),o=this.getSubLayerRow.bind(this);let r={};const a={};if(Array.isArray(i.dataChanged)){const t=this.state.features;for(const e in t)r[e]=t[e].slice(),a[e]=[];for(const e of i.dataChanged){const i=st(n,o,e);for(const n in t)a[n].push((0,s.b)({data:r[n],getIndex:t=>t.__source.index,dataRange:e,replace:i[n]}))}}else r=st(n,o);const l=function(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:n,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=t;return i.points.data=n,i.points._dataDiff=e.pointFeatures&&(()=>e.pointFeatures),i.points.getPosition=lt,i.lines.data=o,i.lines._dataDiff=e.lineFeatures&&(()=>e.lineFeatures),i.lines.getPath=lt,i.polygons.data=s,i.polygons._dataDiff=e.polygonFeatures&&(()=>e.polygonFeatures),i.polygons.getPolygon=lt,i.polygonsOutline.data=r,i.polygonsOutline._dataDiff=e.polygonOutlineFeatures&&(()=>e.polygonOutlineFeatures),i.polygonsOutline.getPath=lt,i}(r,a);this.setState({features:r,featuresDiff:a,layerProps:l})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i,sourceLayer:n}=e;return e.featureType=ct.find((t=>n.id.startsWith("".concat(this.id,"-").concat(t,"-")))),i>=0&&n.id.startsWith("".concat(this.id,"-points-text"))&&this.state.binary&&(e.index=this.props.data.points.globalFeatureIds.value[i]),e}_updateAutoHighlight(t){const e="".concat(this.id,"-points-"),i="points"===t.featureType;for(const n of this.getSubLayers())n.id.startsWith(e)===i&&n.updateAutoHighlight(t)}_renderPolygonLayer(){const{extruded:t,wireframe:e}=this.props,{layerProps:i}=this.state,n="polygons-fill",o=this.shouldRenderSubLayer(n,i.polygons.data)&&this.getSubLayerClass(n,it.type);if(o){const s=ot(this,it.props),r=t&&e;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){const{extruded:t,stroked:e}=this.props,{layerProps:i}=this.state,n="polygons-stroke",o="linestrings",s=!t&&e&&this.shouldRenderSubLayer(n,i.polygonsOutline.data)&&this.getSubLayerClass(n,et.type),r=this.shouldRenderSubLayer(o,i.lines.data)&&this.getSubLayerClass(o,et.type);if(s||r){const t=ot(this,et.props);return[s&&new s(t,this.getSubLayerProps({id:n,updateTriggers:t.updateTriggers}),i.polygonsOutline),r&&new r(t,this.getSubLayerProps({id:o,updateTriggers:t.updateTriggers}),i.lines)]}return null}_renderPointLayers(){const{pointType:t}=this.props,{layerProps:e,binary:i}=this.state;let{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=e.points.data.findIndex((t=>t.__source.index===n)));const o=new Set(t.split("+")),s=[];for(const t of o){const o="points-".concat(t),r=tt[t],a=r&&this.shouldRenderSubLayer(o,e.points.data)&&this.getSubLayerClass(o,r.type);if(a){const l=ot(this,r.props);let c=e.points;if("text"===t&&i){const{instancePickingColors:t,...e}=c.data.attributes;c={...c,data:{...c.data,attributes:e}}}s.push(new a(l,this.getSubLayerProps({id:o,updateTriggers:l.updateTriggers,highlightedObjectIndex:n}),c))}}return s}renderLayers(){const{extruded:t}=this.props,e=this._renderPolygonLayer();return[!t&&e,this._renderLineLayers(),this._renderPointLayers(),t&&e]}getSubLayerAccessor(t){const{binary:e}=this.state;return e&&"function"==typeof t?(e,i)=>{const{data:n,index:o}=i,s=function(t,e){if(!t)return null;const i="startIndices"in t?t.startIndices[e]:e,n=t.featureIds.value[i];return-1!==i?function(t,e,i){const n={properties:{...t.properties[e]}};for(const e in t.numericProps)n.properties[e]=t.numericProps[e].value[i];return n}(t,n,i):null}(n,o);return t(s,i)}:super.getSubLayerAccessor(t)}}(0,n.Z)(dt,"layerName","GeoJsonLayer"),(0,n.Z)(dt,"defaultProps",ut)},48897:(t,e,i)=>{"use strict";i.d(e,{Z:()=>v});var n=i(4942),o=i(5259),s=i(37832),r=i(13717),a=i(33321),l=i(39769),c=i(53982),u=i(44500),d=i(25215);class g extends u.Z{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?function(t,e,i,n){let o;if(Array.isArray(t[0])){const i=t.length*e;o=new Array(i);for(let i=0;i<t.length;i++)for(let n=0;n<e;n++)o[i*e+n]=t[i][n]||0}else o=t;return i?(0,d.dj)(o,{size:e,gridResolution:i}):n?(0,d.ct)(o,{size:e}):o}(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(f(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&f(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const i=this.attributes.segmentTypes,n=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:s}=e;i.fill(0,o,o+s),n?(i[o]=4,i[o+s-2]=4):(i[o]+=1,i[o+s-2]+=2),i[o+s-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i||!t)return;const{vertexStart:n,geometrySize:o}=e,s=new Array(3);for(let e=n,r=0;r<o;e++,r++)this.getPointOnPath(t,r,s),i[3*e]=s[0],i[3*e+1]=s[1],i[3*e+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i){void 0===i&&(i=[]);const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const o=e*n;return i[0]=t[o],i[1]=t[o+1],i[2]=3===n&&t[o+2]||0,i}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}function f(t){return Array.isArray(t[0])}const p=[0,0,0,255],h={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:p},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},y={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class v extends o.Z{constructor(){super(...arguments),(0,n.Z)(this,"state",void 0)}getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:y,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:y,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:y,defaultValue:p},instancePickingColors:{size:3,type:5121,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(t&&t.__source?t.__source.index:i,n)}}}),this.setState({pathTesselator:new g({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:i}=t,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var o;const{gl:t}=this.context;null===(o=this.state.model)||void 0===o||o.delete(),this.state.model=this._getModel(t),n.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else super.disablePickingIndex(t)}draw(t){let{uniforms:e}=t;const{jointRounded:i,capRounded:n,billboard:o,miterLimit:s,widthUnits:r,widthScale:l,widthMinPixels:c,widthMaxPixels:u}=this.props;this.state.model.setUniforms(e).setUniforms({jointType:Number(i),capType:Number(n),billboard:o,widthUnits:a.iI[r],widthScale:l,miterLimit:s,widthMinPixels:c,widthMaxPixels:u}).draw()}_getModel(t){return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}(0,n.Z)(v,"defaultProps",h),(0,n.Z)(v,"layerName","PathLayer")},73715:(t,e,i)=>{"use strict";i.d(e,{Z:()=>g});var n=i(4942),o=i(5259),s=i(37832),r=i(13717),a=i(33321),l=i(39769),c=i(53982);const u=[0,0,0,255],d={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:u},getLineColor:{type:"accessor",value:u},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class g extends o.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[s.Z,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null===(e=this.state.model)||void 0===e||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{radiusUnits:i,radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,stroked:r,filled:l,billboard:c,antialiasing:u,lineWidthUnits:d,lineWidthScale:g,lineWidthMinPixels:f,lineWidthMaxPixels:p}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:r?1:0,filled:l,billboard:c,antialiasing:u,radiusUnits:a.iI[i],radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,lineWidthUnits:a.iI[d],lineWidthScale:g,lineWidthMinPixels:f,lineWidthMaxPixels:p}).draw()}_getModel(t){return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}(0,n.Z)(g,"defaultProps",d),(0,n.Z)(g,"layerName","ScatterplotLayer")},67186:(t,e,i)=>{"use strict";function n(t){let{data:e,getIndex:i,dataRange:n,replace:o}=t;const{startRow:s=0,endRow:r=1/0}=n,a=e.length;let l=a,c=a;for(let t=0;t<a;t++){const n=i(e[t]);if(l>t&&n>=s&&(l=t),n>=r){c=t;break}}let u=l;const d=c-l!==o.length?e.slice(c):void 0;for(let t=0;t<o.length;t++)e[u++]=o[t];if(d){for(let t=0;t<d.length;t++)e[u++]=d[t];e.length=u}return{startRow:l,endRow:l+o.length}}i.d(e,{b:()=>n})},63:(t,e,i)=>{"use strict";function n(t){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.reduce((function(t,e){return t.concat(n(e))}),[]),t;case"Feature":return t.geometry?n(t.geometry).map((function(e){var i={type:"Feature",properties:JSON.parse(JSON.stringify(t.properties)),geometry:e};return void 0!==t.id&&(i.id=t.id),i})):[t];case"MultiPoint":return t.coordinates.map((function(t){return{type:"Point",coordinates:t}}));case"MultiPolygon":return t.coordinates.map((function(t){return{type:"Polygon",coordinates:t}}));case"MultiLineString":return t.coordinates.map((function(t){return{type:"LineString",coordinates:t}}));case"GeometryCollection":return t.geometries.map(n).reduce((function(t,e){return t.concat(e)}),[]);case"Point":case"Polygon":case"LineString":return[t]}}i.r(e),i.d(e,{default:()=>n})},13692:t=>{var e=t.exports=function(t){return new i(t)};function i(t){this.value=t}function n(t,e,i){var n=[],r=[],u=!0;return function t(d){var g=i?o(d):d,f={},p=!0,h={node:g,node_:d,path:[].concat(n),parent:r[r.length-1],parents:r,key:n.slice(-1)[0],isRoot:0===n.length,level:n.length,circular:null,update:function(t,e){h.isRoot||(h.parent.node[h.key]=t),h.node=t,e&&(p=!1)},delete:function(t){delete h.parent.node[h.key],t&&(p=!1)},remove:function(t){a(h.parent.node)?h.parent.node.splice(h.key,1):delete h.parent.node[h.key],t&&(p=!1)},keys:null,before:function(t){f.before=t},after:function(t){f.after=t},pre:function(t){f.pre=t},post:function(t){f.post=t},stop:function(){u=!1},block:function(){p=!1}};if(!u)return h;function y(){if("object"==typeof h.node&&null!==h.node){h.keys&&h.node_===h.node||(h.keys=s(h.node)),h.isLeaf=0==h.keys.length;for(var t=0;t<r.length;t++)if(r[t].node_===d){h.circular=r[t];break}}else h.isLeaf=!0,h.keys=null;h.notLeaf=!h.isLeaf,h.notRoot=!h.isRoot}y();var v=e.call(h,h.node);return void 0!==v&&h.update&&h.update(v),f.before&&f.before.call(h,h.node),p?("object"!=typeof h.node||null===h.node||h.circular||(r.push(h),y(),l(h.keys,(function(e,o){n.push(e),f.pre&&f.pre.call(h,h.node[e],e);var s=t(h.node[e]);i&&c.call(h.node,e)&&(h.node[e]=s.node),s.isLast=o==h.keys.length-1,s.isFirst=0==o,f.post&&f.post.call(h,s),n.pop()})),r.pop()),f.after&&f.after.call(h,h.node),h):h}(t).node}function o(t){if("object"==typeof t&&null!==t){var e;if(a(t))e=[];else if("[object Date]"===r(t))e=new Date(t.getTime?t.getTime():t);else if("[object RegExp]"===r(t))e=new RegExp(t);else if(function(t){return"[object Error]"===r(t)}(t))e={message:t.message};else if(function(t){return"[object Boolean]"===r(t)}(t))e=new Boolean(t);else if(function(t){return"[object Number]"===r(t)}(t))e=new Number(t);else if(function(t){return"[object String]"===r(t)}(t))e=new String(t);else if(Object.create&&Object.getPrototypeOf)e=Object.create(Object.getPrototypeOf(t));else if(t.constructor===Object)e={};else{var i=t.constructor&&t.constructor.prototype||t.__proto__||{},n=function(){};n.prototype=i,e=new n}return l(s(t),(function(i){e[i]=t[i]})),e}return t}i.prototype.get=function(t){for(var e=this.value,i=0;i<t.length;i++){var n=t[i];if(!e||!c.call(e,n)){e=void 0;break}e=e[n]}return e},i.prototype.has=function(t){for(var e=this.value,i=0;i<t.length;i++){var n=t[i];if(!e||!c.call(e,n))return!1;e=e[n]}return!0},i.prototype.set=function(t,e){for(var i=this.value,n=0;n<t.length-1;n++){var o=t[n];c.call(i,o)||(i[o]={}),i=i[o]}return i[t[n]]=e,e},i.prototype.map=function(t){return n(this.value,t,!0)},i.prototype.forEach=function(t){return this.value=n(this.value,t,!1),this.value},i.prototype.reduce=function(t,e){var i=1===arguments.length,n=i?this.value:e;return this.forEach((function(e){this.isRoot&&i||(n=t.call(this,n,e))})),n},i.prototype.paths=function(){var t=[];return this.forEach((function(e){t.push(this.path)})),t},i.prototype.nodes=function(){var t=[];return this.forEach((function(e){t.push(this.node)})),t},i.prototype.clone=function(){var t=[],e=[];return function i(n){for(var r=0;r<t.length;r++)if(t[r]===n)return e[r];if("object"==typeof n&&null!==n){var a=o(n);return t.push(n),e.push(a),l(s(n),(function(t){a[t]=i(n[t])})),t.pop(),e.pop(),a}return n}(this.value)};var s=Object.keys||function(t){var e=[];for(var i in t)e.push(i);return e};function r(t){return Object.prototype.toString.call(t)}var a=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},l=function(t,e){if(t.forEach)return t.forEach(e);for(var i=0;i<t.length;i++)e(t[i],i,t)};l(s(i.prototype),(function(t){e[t]=function(e){var n=[].slice.call(arguments,1),o=new i(e);return o[t].apply(o,n)}}));var c=Object.hasOwnProperty||function(t,e){return e in t}}}]);
//# sourceMappingURL=c53ea7b1df2af56542a2.chunk.js.map