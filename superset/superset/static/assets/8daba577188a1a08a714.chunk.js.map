{"version":3,"file":"8daba577188a1a08a714.chunk.js","mappings":"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","sources":["webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/roundDecimal.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/geo.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/ScatterPlotGlowOverlay.jsx","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/utils/luminanceFromRGB.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/MapBox.jsx","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/sort.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/within.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/index.js","webpack://superset/./node_modules/supercluster/index.js","webpack://superset/./node_modules/supercluster/node_modules/kdbush/src/range.js","webpack://superset/./plugins/legacy-plugin-chart-map-box/src/transformProps.js"],"sourcesContent":["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport default function roundDecimal(number, precision) {\n  let roundedNumber;\n  let p = precision;\n  if (precision) {\n    roundedNumber = Math.round(number * (p = 10 ** p)) / p;\n  } else {\n    roundedNumber = Math.round(number);\n  }\n\n  return roundedNumber;\n}\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport roundDecimal from './roundDecimal';\n\nexport const EARTH_CIRCUMFERENCE_KM = 40075.16;\nexport const MILES_PER_KM = 1.60934;\n\nexport function kmToPixels(kilometers, latitude, zoomLevel) {\n  // Algorithm from: http://wiki.openstreetmap.org/wiki/Zoom_levels\n  const latitudeRad = latitude * (Math.PI / 180);\n  // Seems like the zoomLevel is off by one\n  const kmPerPixel =\n    (EARTH_CIRCUMFERENCE_KM * Math.cos(latitudeRad)) / 2 ** (zoomLevel + 9);\n\n  return roundDecimal(kilometers / kmPerPixel, 2);\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/require-default-props */\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport { CanvasOverlay } from 'react-map-gl';\nimport { kmToPixels, MILES_PER_KM } from './utils/geo';\nimport roundDecimal from './utils/roundDecimal';\nimport luminanceFromRGB from './utils/luminanceFromRGB';\nimport 'mapbox-gl/dist/mapbox-gl.css';\n\nconst propTypes = {\n  aggregation: PropTypes.string,\n  compositeOperation: PropTypes.string,\n  dotRadius: PropTypes.number,\n  lngLatAccessor: PropTypes.func,\n  locations: PropTypes.arrayOf(PropTypes.object).isRequired,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.arrayOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  zoom: PropTypes.number,\n};\n\nconst defaultProps = {\n  // Same as browser default.\n  compositeOperation: 'source-over',\n  dotRadius: 4,\n  lngLatAccessor: location => [location[0], location[1]],\n  renderWhileDragging: true,\n};\n\nconst computeClusterLabel = (properties, aggregation) => {\n  const count = properties.point_count;\n  if (!aggregation) {\n    return count;\n  }\n  if (aggregation === 'sum' || aggregation === 'min' || aggregation === 'max') {\n    return properties[aggregation];\n  }\n  const { sum } = properties;\n  const mean = sum / count;\n  if (aggregation === 'mean') {\n    return Math.round(100 * mean) / 100;\n  }\n  const { squaredSum } = properties;\n  const variance = squaredSum / count - (sum / count) ** 2;\n  if (aggregation === 'var') {\n    return Math.round(100 * variance) / 100;\n  }\n  if (aggregation === 'stdev') {\n    return Math.round(100 * Math.sqrt(variance)) / 100;\n  }\n\n  // fallback to point_count, this really shouldn't happen\n  return count;\n};\n\nclass ScatterPlotGlowOverlay extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.redraw = this.redraw.bind(this);\n  }\n\n  drawText(ctx, pixel, options = {}) {\n    const IS_DARK_THRESHOLD = 110;\n    const {\n      fontHeight = 0,\n      label = '',\n      radius = 0,\n      rgb = [0, 0, 0],\n      shadow = false,\n    } = options;\n    const maxWidth = radius * 1.8;\n    const luminance = luminanceFromRGB(rgb[1], rgb[2], rgb[3]);\n\n    ctx.globalCompositeOperation = 'source-over';\n    ctx.fillStyle = luminance <= IS_DARK_THRESHOLD ? 'white' : 'black';\n    ctx.font = `${fontHeight}px sans-serif`;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    if (shadow) {\n      ctx.shadowBlur = 15;\n      ctx.shadowColor = luminance <= IS_DARK_THRESHOLD ? 'black' : '';\n    }\n\n    const textWidth = ctx.measureText(label).width;\n    if (textWidth > maxWidth) {\n      const scale = fontHeight / textWidth;\n      ctx.font = `${scale * maxWidth}px sans-serif`;\n    }\n\n    const { compositeOperation } = this.props;\n\n    ctx.fillText(label, pixel[0], pixel[1]);\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.shadowBlur = 0;\n    ctx.shadowColor = '';\n  }\n\n  // Modified: https://github.com/uber/react-map-gl/blob/master/overlays/scatterplot.react.js\n  redraw({ width, height, ctx, isDragging, project }) {\n    const {\n      aggregation,\n      compositeOperation,\n      dotRadius,\n      lngLatAccessor,\n      locations,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      zoom,\n    } = this.props;\n\n    const radius = dotRadius;\n    const clusterLabelMap = [];\n\n    locations.forEach((location, i) => {\n      if (location.properties.cluster) {\n        clusterLabelMap[i] = computeClusterLabel(\n          location.properties,\n          aggregation,\n        );\n      }\n    }, this);\n\n    const maxLabel = Math.max(...clusterLabelMap.filter(v => !Number.isNaN(v)));\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalCompositeOperation = compositeOperation;\n\n    if ((renderWhileDragging || !isDragging) && locations) {\n      locations.forEach(function _forEach(location, i) {\n        const pixel = project(lngLatAccessor(location));\n        const pixelRounded = [\n          roundDecimal(pixel[0], 1),\n          roundDecimal(pixel[1], 1),\n        ];\n\n        if (\n          pixelRounded[0] + radius >= 0 &&\n          pixelRounded[0] - radius < width &&\n          pixelRounded[1] + radius >= 0 &&\n          pixelRounded[1] - radius < height\n        ) {\n          ctx.beginPath();\n          if (location.properties.cluster) {\n            let clusterLabel = clusterLabelMap[i];\n            const scaledRadius = roundDecimal(\n              (clusterLabel / maxLabel) ** 0.5 * radius,\n              1,\n            );\n            const fontHeight = roundDecimal(scaledRadius * 0.5, 1);\n            const [x, y] = pixelRounded;\n            const gradient = ctx.createRadialGradient(\n              x,\n              y,\n              scaledRadius,\n              x,\n              y,\n              0,\n            );\n\n            gradient.addColorStop(\n              1,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0.8)`,\n            );\n            gradient.addColorStop(\n              0,\n              `rgba(${rgb[1]}, ${rgb[2]}, ${rgb[3]}, 0)`,\n            );\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              scaledRadius,\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = gradient;\n            ctx.fill();\n\n            if (Number.isFinite(parseFloat(clusterLabel))) {\n              if (clusterLabel >= 10000) {\n                clusterLabel = `${Math.round(clusterLabel / 1000)}k`;\n              } else if (clusterLabel >= 1000) {\n                clusterLabel = `${Math.round(clusterLabel / 100) / 10}k`;\n              }\n              this.drawText(ctx, pixelRounded, {\n                fontHeight,\n                label: clusterLabel,\n                radius: scaledRadius,\n                rgb,\n                shadow: true,\n              });\n            }\n          } else {\n            const defaultRadius = radius / 6;\n            const radiusProperty = location.properties.radius;\n            const pointMetric = location.properties.metric;\n            let pointRadius =\n              radiusProperty === null ? defaultRadius : radiusProperty;\n            let pointLabel;\n\n            if (radiusProperty !== null) {\n              const pointLatitude = lngLatAccessor(location)[1];\n              if (pointRadiusUnit === 'Kilometers') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}km`;\n                pointRadius = kmToPixels(pointRadius, pointLatitude, zoom);\n              } else if (pointRadiusUnit === 'Miles') {\n                pointLabel = `${roundDecimal(pointRadius, 2)}mi`;\n                pointRadius = kmToPixels(\n                  pointRadius * MILES_PER_KM,\n                  pointLatitude,\n                  zoom,\n                );\n              }\n            }\n\n            if (pointMetric !== null) {\n              pointLabel = Number.isFinite(parseFloat(pointMetric))\n                ? roundDecimal(pointMetric, 2)\n                : pointMetric;\n            }\n\n            // Fall back to default points if pointRadius wasn't a numerical column\n            if (!pointRadius) {\n              pointRadius = defaultRadius;\n            }\n\n            ctx.arc(\n              pixelRounded[0],\n              pixelRounded[1],\n              roundDecimal(pointRadius, 1),\n              0,\n              Math.PI * 2,\n            );\n            ctx.fillStyle = `rgb(${rgb[1]}, ${rgb[2]}, ${rgb[3]})`;\n            ctx.fill();\n\n            if (pointLabel !== undefined) {\n              this.drawText(ctx, pixelRounded, {\n                fontHeight: roundDecimal(pointRadius, 1),\n                label: pointLabel,\n                radius: pointRadius,\n                rgb,\n                shadow: false,\n              });\n            }\n          }\n        }\n      }, this);\n    }\n  }\n\n  render() {\n    return <CanvasOverlay redraw={this.redraw} />;\n  }\n}\n\nScatterPlotGlowOverlay.propTypes = propTypes;\nScatterPlotGlowOverlay.defaultProps = defaultProps;\n\nexport default ScatterPlotGlowOverlay;\n","/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nexport const LUMINANCE_RED_WEIGHT = 0.2126;\nexport const LUMINANCE_GREEN_WEIGHT = 0.7152;\nexport const LUMINANCE_BLUE_WEIGHT = 0.0722;\n\nexport default function luminanceFromRGB(r, g, b) {\n  // Formula: https://en.wikipedia.org/wiki/Relative_luminance\n  return (\n    LUMINANCE_RED_WEIGHT * r +\n    LUMINANCE_GREEN_WEIGHT * g +\n    LUMINANCE_BLUE_WEIGHT * b\n  );\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable react/jsx-sort-default-props, react/sort-prop-types */\n/* eslint-disable react/forbid-prop-types, react/require-default-props */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport MapGL from 'react-map-gl';\nimport ViewportMercator from 'viewport-mercator-project';\nimport ScatterPlotGlowOverlay from './ScatterPlotGlowOverlay';\nimport './MapBox.css';\n\nconst NOOP = () => {};\nexport const DEFAULT_MAX_ZOOM = 16;\nexport const DEFAULT_POINT_RADIUS = 60;\n\nconst propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  aggregatorName: PropTypes.string,\n  clusterer: PropTypes.object,\n  globalOpacity: PropTypes.number,\n  hasCustomMetric: PropTypes.bool,\n  mapStyle: PropTypes.string,\n  mapboxApiKey: PropTypes.string.isRequired,\n  onViewportChange: PropTypes.func,\n  pointRadius: PropTypes.number,\n  pointRadiusUnit: PropTypes.string,\n  renderWhileDragging: PropTypes.bool,\n  rgb: PropTypes.array,\n  bounds: PropTypes.array,\n};\n\nconst defaultProps = {\n  width: 400,\n  height: 400,\n  globalOpacity: 1,\n  onViewportChange: NOOP,\n  pointRadius: DEFAULT_POINT_RADIUS,\n  pointRadiusUnit: 'Pixels',\n};\n\nclass MapBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    const { width, height, bounds } = this.props;\n    // Get a viewport that fits the given bounds, which all marks to be clustered.\n    // Derive lat, lon and zoom from this viewport. This is only done on initial\n    // render as the bounds don't update as we pan/zoom in the current design.\n    const mercator = new ViewportMercator({\n      width,\n      height,\n    }).fitBounds(bounds);\n    const { latitude, longitude, zoom } = mercator;\n\n    this.state = {\n      viewport: {\n        longitude,\n        latitude,\n        zoom,\n      },\n    };\n    this.handleViewportChange = this.handleViewportChange.bind(this);\n  }\n\n  handleViewportChange(viewport) {\n    this.setState({ viewport });\n    const { onViewportChange } = this.props;\n    onViewportChange(viewport);\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      aggregatorName,\n      clusterer,\n      globalOpacity,\n      mapStyle,\n      mapboxApiKey,\n      pointRadius,\n      pointRadiusUnit,\n      renderWhileDragging,\n      rgb,\n      hasCustomMetric,\n      bounds,\n    } = this.props;\n    const { viewport } = this.state;\n    const isDragging =\n      viewport.isDragging === undefined ? false : viewport.isDragging;\n\n    // Compute the clusters based on the original bounds and current zoom level. Note when zoom/pan\n    // to an area outside of the original bounds, no additional queries are made to the backend to\n    // retrieve additional data.\n    // add this variable to widen the visible area\n    const offsetHorizontal = (width * 0.5) / 100;\n    const offsetVertical = (height * 0.5) / 100;\n    const bbox = [\n      bounds[0][0] - offsetHorizontal,\n      bounds[0][1] - offsetVertical,\n      bounds[1][0] + offsetHorizontal,\n      bounds[1][1] + offsetVertical,\n    ];\n    const clusters = clusterer.getClusters(bbox, Math.round(viewport.zoom));\n\n    return (\n      <MapGL\n        {...viewport}\n        mapStyle={mapStyle}\n        width={width}\n        height={height}\n        mapboxApiAccessToken={mapboxApiKey}\n        onViewportChange={this.handleViewportChange}\n        preserveDrawingBuffer\n      >\n        <ScatterPlotGlowOverlay\n          {...viewport}\n          isDragging={isDragging}\n          locations={clusters}\n          dotRadius={pointRadius}\n          pointRadiusUnit={pointRadiusUnit}\n          rgb={rgb}\n          globalOpacity={globalOpacity}\n          compositeOperation=\"screen\"\n          renderWhileDragging={renderWhileDragging}\n          aggregation={hasCustomMetric ? aggregatorName : null}\n          lngLatAccessor={location => {\n            const { coordinates } = location.geometry;\n\n            return [coordinates[0], coordinates[1]];\n          }}\n        />\n      </MapGL>\n    );\n  }\n}\n\nMapBox.propTypes = propTypes;\nMapBox.defaultProps = defaultProps;\n\nexport default MapBox;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    var m = Math.floor((left + right) / 2);\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nexport default function kdbush(points, getX, getY, nodeSize, ArrayType) {\n    return new KDBush(points, getX, getY, nodeSize, ArrayType);\n}\n\nfunction KDBush(points, getX, getY, nodeSize, ArrayType) {\n    getX = getX || defaultGetX;\n    getY = getY || defaultGetY;\n    ArrayType = ArrayType || Array;\n\n    this.nodeSize = nodeSize || 64;\n    this.points = points;\n\n    this.ids = new ArrayType(points.length);\n    this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        this.ids[i] = i;\n        this.coords[2 * i] = getX(points[i]);\n        this.coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);\n}\n\nKDBush.prototype = {\n    range: function (minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    },\n\n    within: function (x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n};\n\nfunction defaultGetX(p) { return p[0]; }\nfunction defaultGetY(p) { return p[1]; }\n","\nimport kdbush from 'kdbush';\n\nexport default function supercluster(options) {\n    return new SuperCluster(options);\n}\n\nfunction SuperCluster(options) {\n    this.options = extend(Object.create(this.options), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n}\n\nSuperCluster.prototype = {\n    options: {\n        minZoom: 0,   // min zoom to generate clusters on\n        maxZoom: 16,  // max zoom level to cluster the points on\n        radius: 40,   // cluster radius in pixels\n        extent: 512,  // tile extent (radius is calculated relative to it)\n        nodeSize: 64, // size of the KD-tree leaf node, affects performance\n        log: false,   // whether to log timing info\n\n        // a reduce function for calculating custom cluster properties\n        reduce: null, // function (accumulated, props) { accumulated.sum += props.sum; }\n\n        // initial properties of a cluster (before running the reducer)\n        initial: function () { return {}; }, // function () { return {sum: 0}; },\n\n        // properties to use for individual points when running the reducer\n        map: function (props) { return props; } // function (props) { return {sum: props.my_value}; },\n    },\n\n    load: function (points) {\n        var log = this.options.log;\n\n        if (log) console.time('total time');\n\n        var timerId = 'prepare ' + points.length + ' points';\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        var clusters = [];\n        for (var i = 0; i < points.length; i++) {\n            if (!points[i].geometry) {\n                continue;\n            }\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[this.options.maxZoom + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {\n            var now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    },\n\n    getClusters: function (bbox, zoom) {\n        var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        var minLat = Math.max(-90, Math.min(90, bbox[1]));\n        var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        var tree = this.trees[this._limitZoom(zoom)];\n        var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        var clusters = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = tree.points[ids[i]];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    },\n\n    getChildren: function (clusterId) {\n        var originId = clusterId >> 5;\n        var originZoom = clusterId % 32;\n        var errorMsg = 'No cluster with the specified id.';\n\n        var index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        var origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        var ids = index.within(origin.x, origin.y, r);\n        var children = [];\n        for (var i = 0; i < ids.length; i++) {\n            var c = index.points[ids[i]];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    },\n\n    getLeaves: function (clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        var leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    },\n\n    getTile: function (z, x, y) {\n        var tree = this.trees[this._limitZoom(z)];\n        var z2 = Math.pow(2, z);\n        var extent = this.options.extent;\n        var r = this.options.radius;\n        var p = r / extent;\n        var top = (y - p) / z2;\n        var bottom = (y + 1 + p) / z2;\n\n        var tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    },\n\n    getClusterExpansionZoom: function (clusterId) {\n        var clusterZoom = (clusterId % 32) - 1;\n        while (clusterZoom < this.options.maxZoom) {\n            var children = this.getChildren(clusterId);\n            clusterZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return clusterZoom;\n    },\n\n    _appendLeaves: function (result, clusterId, limit, offset, skipped) {\n        var children = this.getChildren(clusterId);\n\n        for (var i = 0; i < children.length; i++) {\n            var props = children[i].properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(children[i]);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    },\n\n    _addTileFeatures: function (ids, points, x, y, z2, tile) {\n        for (var i = 0; i < ids.length; i++) {\n            var c = points[ids[i]];\n            var f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n            };\n            var id = c.numPoints ? c.id : this.points[c.index].id;\n            if (id !== undefined) {\n                f.id = id;\n            }\n            tile.features.push(f);\n        }\n    },\n\n    _limitZoom: function (z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    },\n\n    _cluster: function (points, zoom) {\n        var clusters = [];\n        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            var tree = this.trees[zoom + 1];\n            var neighborIds = tree.within(p.x, p.y, r);\n\n            var numPoints = p.numPoints || 1;\n            var wx = p.x * numPoints;\n            var wy = p.y * numPoints;\n\n            var clusterProperties = null;\n\n            if (this.options.reduce) {\n                clusterProperties = this.options.initial();\n                this._accumulate(clusterProperties, p);\n            }\n\n            // encode both zoom and point index on which the cluster originated\n            var id = (i << 5) + (zoom + 1);\n\n            for (var j = 0; j < neighborIds.length; j++) {\n                var b = tree.points[neighborIds[j]];\n                // filter out neighbors that are already processed\n                if (b.zoom <= zoom) continue;\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b.numPoints || 1;\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b.y * numPoints2;\n\n                numPoints += numPoints2;\n                b.parentId = id;\n\n                if (this.options.reduce) {\n                    this._accumulate(clusterProperties, b);\n                }\n            }\n\n            if (numPoints === 1) {\n                clusters.push(p);\n            } else {\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n            }\n        }\n\n        return clusters;\n    },\n\n    _accumulate: function (clusterProperties, point) {\n        var properties = point.numPoints ?\n            point.properties :\n            this.options.map(this.points[point.index].properties);\n\n        this.options.reduce(clusterProperties, properties);\n    }\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: x, // weighted cluster center\n        y: y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var coords = p.geometry.coordinates;\n    return {\n        x: lngX(coords[0]), // projected point coordinates\n        y: latY(coords[1]),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? Math.round(count / 1000) + 'k' :\n        count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport supercluster from 'supercluster';\nimport { DEFAULT_POINT_RADIUS, DEFAULT_MAX_ZOOM } from './MapBox';\n\nconst NOOP = () => {};\n\nexport default function transformProps(chartProps) {\n  const { width, height, formData, hooks, queriesData } = chartProps;\n  const { onError = NOOP, setControlValue = NOOP } = hooks;\n  const { bounds, geoJSON, hasCustomMetric, mapboxApiKey } =\n    queriesData[0].data;\n  const {\n    clusteringRadius,\n    globalOpacity,\n    mapboxColor,\n    mapboxStyle,\n    pandasAggfunc,\n    pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n  } = formData;\n\n  // Validate mapbox color\n  const rgb = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/.exec(mapboxColor);\n  if (rgb === null) {\n    onError(\"Color field must be of form 'rgb(%d, %d, %d)'\");\n\n    return {};\n  }\n\n  const opts = {\n    maxZoom: DEFAULT_MAX_ZOOM,\n    radius: clusteringRadius,\n  };\n  if (hasCustomMetric) {\n    opts.initial = () => ({\n      sum: 0,\n      squaredSum: 0,\n      min: Infinity,\n      max: -Infinity,\n    });\n    opts.map = prop => ({\n      sum: prop.metric,\n      squaredSum: prop.metric ** 2,\n      min: prop.metric,\n      max: prop.metric,\n    });\n    opts.reduce = (accu, prop) => {\n      // Temporarily disable param-reassignment linting to work with supercluster's api\n      /* eslint-disable no-param-reassign */\n      accu.sum += prop.sum;\n      accu.squaredSum += prop.squaredSum;\n      accu.min = Math.min(accu.min, prop.min);\n      accu.max = Math.max(accu.max, prop.max);\n      /* eslint-enable no-param-reassign */\n    };\n  }\n  const clusterer = supercluster(opts);\n  clusterer.load(geoJSON.features);\n\n  return {\n    width,\n    height,\n    aggregatorName: pandasAggfunc,\n    bounds,\n    clusterer,\n    globalOpacity,\n    hasCustomMetric,\n    mapboxApiKey,\n    mapStyle: mapboxStyle,\n    onViewportChange({ latitude, longitude, zoom }) {\n      setControlValue('viewport_longitude', longitude);\n      setControlValue('viewport_latitude', latitude);\n      setControlValue('viewport_zoom', zoom);\n    },\n    pointRadius: pointRadius === 'Auto' ? DEFAULT_POINT_RADIUS : pointRadius,\n    pointRadiusUnit,\n    renderWhileDragging,\n    rgb,\n  };\n}\n"],"names":["roundDecimal","number","precision","roundedNumber","p","Math","round","kmToPixels","kilometers","latitude","zoomLevel","latitudeRad","PI","cos","propTypes","aggregation","PropTypes","compositeOperation","dotRadius","lngLatAccessor","locations","isRequired","pointRadiusUnit","renderWhileDragging","rgb","zoom","ScatterPlotGlowOverlay","React","constructor","props","super","this","redraw","bind","drawText","ctx","pixel","options","fontHeight","label","radius","shadow","maxWidth","luminance","globalCompositeOperation","fillStyle","font","textAlign","textBaseline","shadowBlur","shadowColor","textWidth","measureText","width","scale","fillText","_ref","height","isDragging","project","clusterLabelMap","forEach","location","i","properties","cluster","computeClusterLabel","count","point_count","sum","mean","squaredSum","variance","sqrt","maxLabel","max","filter","v","Number","isNaN","clearRect","pixelRounded","beginPath","clusterLabel","scaledRadius","x","y","gradient","createRadialGradient","addColorStop","arc","fill","isFinite","parseFloat","defaultRadius","radiusProperty","pointMetric","metric","pointLabel","pointRadius","pointLatitude","undefined","render","___EmotionJSX","CanvasOverlay","defaultProps","DEFAULT_MAX_ZOOM","DEFAULT_POINT_RADIUS","aggregatorName","clusterer","globalOpacity","hasCustomMetric","mapStyle","mapboxApiKey","onViewportChange","bounds","NOOP","MapBox","mercator","ViewportMercator","fitBounds","longitude","state","viewport","handleViewportChange","setState","offsetHorizontal","offsetVertical","bbox","clusters","getClusters","MapGL","_extends","mapboxApiAccessToken","preserveDrawingBuffer","coordinates","geometry","sortKD","ids","coords","nodeSize","left","right","depth","m","floor","k","inc","n","z","log","s","exp","sd","min","t","j","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","kdbush","points","getX","getY","ArrayType","KDBush","defaultGetX","defaultGetY","Array","length","SuperCluster","extend","Object","create","trees","maxZoom","createCluster","id","numPoints","Infinity","parentId","getClusterJSON","type","getClusterProperties","y2","atan","abbrev","cluster_id","point_count_abbreviated","lngX","lng","latY","lat","sin","dest","src","prototype","range","minX","minY","maxX","maxY","stack","result","axis","pop","push","nextAxis","within","r","qx","qy","r2","minZoom","extent","reduce","initial","map","load","console","time","timerId","index","Float32Array","timeEnd","now","Date","_cluster","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","c","getChildren","clusterId","originId","originZoom","errorMsg","Error","origin","pow","children","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","clusterZoom","skipped","f","tags","neighborIds","wx","wy","clusterProperties","_accumulate","b","numPoints2","point","transformProps","chartProps","formData","hooks","queriesData","onError","setControlValue","geoJSON","data","clusteringRadius","mapboxColor","mapboxStyle","pandasAggfunc","exec","opts","prop","accu"],"sourceRoot":""}